#pragma once

#include <functional>

template <class T>
class PIDController
{
public:
    PIDController(double p = 1.0, double i = 1.0, double d = 1.0)
    {
        _p = p;
        _i = i;
        _d = d;
        output = 0;
        enabled = true;
        currentFeedback = 0;
        lastFeedback = 0;
        error = 0;
        lastError = 0;
        currentTime = 0L;
        lastTime = 0L;
        integralCumulation = 0;
        maxCumulation = 30000;
        cycleDerivative = 0;

        inputBounded = false;
        inputLowerBound = 0;
        inputUpperBound = 0;
        outputBounded = false;
        outputLowerBound = 0;
        outputUpperBound = 0;
        feedbackWrapped = false;

        timeFunctionRegistered = false;
    }
    T tick(T currentFeedback, T target)
    {
        if (enabled)
        {
            // Retrieve system feedback from user callback.

            // Apply input bounds if necessary.
            if (inputBounded)
            {
                if (currentFeedback > inputUpperBound)
                    currentFeedback = inputUpperBound;
                if (currentFeedback < inputLowerBound)
                    currentFeedback = inputLowerBound;
            }

            /*
             * Feedback wrapping causes two distant numbers to appear adjacent to one
             * another for the purpose of calculating the system's error.
             */
            if (feedbackWrapped)
            {
                /*
                 * There are three ways to traverse from one point to another in this setup.
                 *
                 *    1)  Target --> Feedback
                 *
                 * The other two ways involve bridging a gap connected by the upper and
                 * lower bounds of the feedback wrap.
                 *
                 *    2)  Target --> Upper Bound == Lower Bound --> Feedback
                 *
                 *    3)  Target --> Lower Bound == Upper Bound --> Feedback
                 *
                 * Of these three paths, one should always be shorter than the other two,
                 * unless all three are equal, in which case it does not matter which path
                 * is taken.
                 */
                float regErr = target - currentFeedback;
                float altErr1 = (target - feedbackWrapLowerBound) + (feedbackWrapUpperBound - currentFeedback);
                float altErr2 = (feedbackWrapUpperBound - target) + (currentFeedback - feedbackWrapLowerBound);

                // Calculate the absolute values of each error.
                float regErrAbs = (regErr >= 0) ? regErr : -regErr;
                float altErr1Abs = (altErr1 >= 0) ? altErr1 : -altErr1;
                float altErr2Abs = (altErr2 >= 0) ? altErr2 : -altErr2;

                // Use the error with the smallest absolute value
                if (regErrAbs <= altErr1Abs && regErrAbs <= altErr2Abs) // If reguErrAbs is smallest
                {
                    error = regErr;
                }
                else if (altErr1Abs < regErrAbs && altErr1Abs < altErr2Abs) // If altErr1Abs is smallest
                {
                    error = altErr1Abs;
                }
                else if (altErr2Abs < regErrAbs && altErr2Abs < altErr1Abs) // If altErr2Abs is smallest
                {
                    error = altErr2Abs;
                }
            }
            else
            {
                // Calculate the error between the feedback and the target.
                error = target - currentFeedback;
            }

            // If we have a registered way to retrieve the system time, use time in PID calculations.
            if (timeFunctionRegistered)
            {
                // Retrieve system time
                currentTime = _getSystemTime();

                // Calculate time since last tick() cycle.
                long deltaTime = currentTime - lastTime;

                // Calculate the integral of the feedback data since last cycle.
                int cycleIntegral = ((lastError + error) / 2) * deltaTime;

                // Add this cycle's integral to the integral cumulation.
                integralCumulation += cycleIntegral;

                // Calculate the slope of the line with data from the current and last cycles.
                cycleDerivative = (error - lastError) / deltaTime;

                // Save time data for next iteration.
                lastTime = currentTime;
            }
            // If we have no way to retrieve system time, estimate calculations.
            else
            {
                integralCumulation += error;
                cycleDerivative = (error - lastError);
            }

            // Prevent the integral cumulation from becoming overwhelmingly huge.
            if (integralCumulation > maxCumulation)
                integralCumulation = maxCumulation;
            if (integralCumulation < -maxCumulation)
                integralCumulation = -maxCumulation;

            // Calculate the system output based on data and PID gains.
            output = (float)((error * _p) + (integralCumulation * _i) + (cycleDerivative * _d));

            // Save a record of this iteration's data.
            lastFeedback = currentFeedback;
            lastError = error;

            // Trim the output to the bounds if needed.
            if (outputBounded)
            {
                if (output > outputUpperBound)
                    output = outputUpperBound;
                if (output < outputLowerBound)
                    output = outputLowerBound;
            }

            return output;
        }
        return currentFeedback;
    }
    T getOutput() { return output; }
    T getFeedback() { return currentFeedback; }
    T getError() { return error; }
    void setEnabled(bool e)
    { // If the PIDController was enabled and is being disabled.
        if (!e && enabled)
        {
            output = 0;
            integralCumulation = 0;
        }
        enabled = e;
    }
    bool isEnabled() { return enabled; }
    T getProportionalComponent() { return (T)(error * _p); }
    T getIntegralComponent() { return (T)(integralCumulation * _i); }
    T getDerivativeComponent() { return (T)(cycleDerivative * _d); }
    void setMaxIntegralCumulation(T max)
    {
        // If the new max value is less than 0, invert to make positive.
        if (max < 0)
        {
            max = -max;
        }

        // If the new max is not more than 1 then the cumulation is useless.
        if (max > 1)
        {
            maxCumulation = max;
        }
    }
    T getMaxIntegralCumulation() { return maxCumulation; }
    T getIntegralCumulation() { return integralCumulation; }

    void setInputBounded(bool bounded) { this->inputBounded = bounded; }
    bool isInputBounded() { return inputBounded; }
    void setInputBounds(T lower, T upper)
    {
        if (upper > lower)
        {
            inputBounded = true;
            inputUpperBound = upper;
            inputLowerBound = lower;
        }
    }
    T getInputLowerBound() { return inputLowerBound; }
    T getInputUpperBound() { return inputUpperBound; }
    void setOutputBounded(bool bounded) { this->outputBounded = bounded; }
    bool isOutputBounded() { return outputBounded; }
    void setOutputBounds(T lower, T upper)
    {
        if (upper > lower)
        {
            outputBounded = true;
            outputLowerBound = lower;
            outputUpperBound = upper;
        }
    }
    T getOutputLowerBound() { return outputLowerBound; }
    T getOutputUpperBound() { return outputUpperBound; }
    void setFeedbackWrapped(bool wrap) { this->feedbackWrapped = wrap; }
    bool isFeedbackWrapped() { return feedbackWrapped; }
    void setFeedbackWrapBounds(T lower, T upper)
    {
        // Make sure no value outside this circular range is ever input.
        setInputBounds(lower, upper);

        feedbackWrapped = true;
        feedbackWrapLowerBound = lower;
        feedbackWrapUpperBound = upper;
    }
    T getFeedbackWrapLowerBound() { return feedbackWrapLowerBound; }
    T getFeedbackWrapUpperBound() { return feedbackWrapUpperBound; }

    void setPID(double p, double i, double d)
    {
        _p = p;
        _i = i;
        _d = d;
    }
    void setP(double p) { this->_p = p; }
    void setI(double i) { this->_i = i; }
    void setD(double d) { this->_d = d; }
    double getP() { return this->_p; }
    double getI() { return this->_i; }
    double getD() { return this->_d; }
    void registerTimeFunction(unsigned long (*getSystemTime)())
    {
        _getSystemTime = getSystemTime;
        timeFunctionRegistered = true;
    }

private:
    double _p;
    double _i;
    double _d;
    T output;
    bool enabled;
    T currentFeedback;
    T lastFeedback;
    T error;
    T lastError;
    long currentTime;
    long lastTime;
    T integralCumulation;
    T maxCumulation;
    T cycleDerivative;

    bool inputBounded;
    T inputLowerBound;
    T inputUpperBound;
    bool outputBounded;
    T outputLowerBound;
    T outputUpperBound;
    bool feedbackWrapped;
    T feedbackWrapLowerBound;
    T feedbackWrapUpperBound;

    bool timeFunctionRegistered;
    unsigned long (*_getSystemTime)();
};

template class PIDController<int>;
template class PIDController<long>;
template class PIDController<float>;
template class PIDController<double>;

// #include "PID.cpp"